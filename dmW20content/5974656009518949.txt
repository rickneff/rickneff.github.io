-*- mode: org -*-
#+title: Class Directed Learning 07
#+language: en
#+options: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t d:(not "HINT")
#+startup: entitiespretty showeverything
#+setupfile: theme-bigblow.setup

  Based on what you learned from file:presentation-07.txt and your reading of
  Chapter 7:

* TODO Discuss the Following
** 1
   If NFA can be converted into DFA, and they both are equivalent to regular
   languages, why is it important to have both of these types of automata?
** 2
   To this point we have only worked with DFA and NFA with small alphabets. Is
   the purpose of NFA to allow us to scale our ability to represent regular
   languages with larger alphabets while still being able to *easily* convert
   back to an actual DFA, or do they serve more as a stepping stone between
   defining regular languages and the other larger language groups
   (context-free/context-sensitive, etc.)?
** 3
   Concering the NFA in Figure 7.3, what benefit comes from putting the ''
   (\epsilon{}-transition) in the middle of the NFA?
** 4
   Explain how the class of regular languages is closed under the
   concatenation operation and the star operation.
** 5
   Can every NFA be converted to an equivalent one that has a single accept
   state? How would you prove or disprove it?
** 6
   Is the DFA generated by the NFA-to-DFA conversion process guaranteed to be
   minimal?

* TODO Minimize a DFA
  Create a minimal DFA equivalent to the one shown below. You will note that
  minimal effort was spent drawing its state diagram, wherein all transitions
  flow from left to right (and the big triangle on the left just means that q_0
  is the start state):

:                [ q1 ]
:               /      \
:   |\       0 /        \ 0, 1
:   | \       /          \         0, 1
:   |  +[ q0 ]            [ q3 ]---------->[[ q4 ]]
:   | /       \          /
:   |/       1 \        / 0, 1
:               \      /
:                [ q2 ]

  What regular expression describes the language recognized by this minimal DFA?

* TODO Design DFA via NFA
  Let /F/ be the language of all strings over {0, 1} that *do not* contain a pair of
  1s that are separated by an odd number of symbols. Create the state diagram of
  a =DFA= with 5 states that recognizes /F/.

  Hint: First find a 4-state NFA for the complement of /F/.

* TODO Ponder and Discuss
  If there is time, consider the ramifications of Noise in your lives!
